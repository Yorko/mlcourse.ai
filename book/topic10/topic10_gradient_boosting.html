
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Topic 10. Gradient Boosting &#8212; mlcourse.ai</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-CN7ZN59CQB"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-CN7ZN59CQB');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-CN7ZN59CQB');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'book/topic10/topic10_gradient_boosting';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://c6.patreon.com/becomePatronButton.bundle.js"></script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Videolecture 10. Gradient boosting" href="videolecture10.html" />
    <link rel="prev" title="Topic 10. Gradient Boosting" href="topic10_intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/mlcourse_ai_logo.jpg" class="logo__image only-light" alt="mlcourse.ai - Home"/>
    <script>document.write(`<img src="../../_static/mlcourse_ai_logo.jpg" class="logo__image only-dark" alt="mlcourse.ai - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Intro
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Prerequisites</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../prereqs/python.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prereqs/math.html">Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prereqs/software_devops.html">Software &amp; DevOps</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 1</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic01/topic01_intro.html">Topic 1 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic01/topic01_pandas_data_analysis.html">Exploratory data analysis with Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic01/videolecture01.html">Videolecture 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic01/assignment01_pandas_uci_adult.html">Demo Assignment 1 Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic01/assignment01_pandas_uci_adult_solution.html">Demo Assignment 1 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic01/bonus_assignment01_pandas_olympics.html">Bonus Assignment 1</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 2</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic02/topic02_intro.html">Topic 2 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic02/topic02_visual_data_analysis.html">Visual Data Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic02/topic02_additional_seaborn_matplotlib_plotly.html">Seaborn, Matplotlib, Plotly</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic02/videolecture02.html">Videolecture 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic02/assignment02_analyzing_cardiovascular_desease_data.html">Demo Assignment 2 Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic02/assignment02_analyzing_cardiovascular_desease_data_solution.html">Demo Assignment 2 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic02/bonus_assignment02_visual_analysis.html">Bonus Assignment 2</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 3</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic03/topic03_intro.html">Topic 3 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic03/topic03_decision_trees_kNN.html">Classification, Decision Trees &amp; k Nearest Neighbors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic03/videolecture03.html">Videolecture 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic03/assignment03_decision_trees.html">Demo Assignment 3 Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic03/assignment03_decision_trees_solution.html">Demo Assignment 3 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic03/bonus_assignment03_decision_trees.html">Bonus Assignment 3</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 4</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic04/topic04_intro.html">Topic 4 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/topic4_linear_models_part1_mse_likelihood_bias_variance.html">Ordinary Least Squares</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/topic4_linear_models_part2_logit_likelihood_learning.html">Linear classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/topic4_linear_models_part3_regul_example.html">An illustrative example of logistic regression regularization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/topic4_linear_models_part4_good_bad_logit_movie_reviews_XOR.html">When logistic regression is good and when it is not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/topic4_linear_models_part5_valid_learning_curves.html">Validation and learning curves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/videolecture04.html">Videolecture 4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/assignment04_regression_wine.html">Demo Assignment 4 Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/assignment04_regression_wine_solution.html">Demo Assignment 4 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic04/bonus_assignment04_alice_baselines.html">Bonus Assignment 4</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 5</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic05/topic05_intro.html">Topic 5 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic05/topic5_part1_bagging.html">Bagging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic05/topic5_part2_random_forest.html">Random Forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic05/topic5_part3_feature_importance.html">Feature importance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic05/videolecture05.html">Videolecture 5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic05/assignment05_logit_rf_credit_scoring.html">Demo Assignment 5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic05/assignment05_logit_rf_credit_scoring_solution.html">Demo Assignment 5 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic05/bonus_assignment05_logreg_rf.html">Bonus Assignment 5</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 6</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic06/topic06_intro.html">Topic 6 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic06/topic6_feature_engineering_feature_selection.html">Feature engineering &amp; feature selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic06/demo_assignment06.html">Demo Assignment 6 Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic06/bonus_assignment06.html">Bonus Assignment 6</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 7</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic07/topic07_intro.html">Topic 7 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic07/topic7_pca_clustering.html">Unsupervised learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic07/videolecture07.html">Videolecture 7</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic07/assignment07_unsupervised_learning.html">Demo Assignment 7</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic07/assignment07_unsupervised_learning_solution.html">Demo Assignment 7 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic07/bonus_assignment07.html">Bonus Assignment 7</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 8</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic08/topic08_intro.html">Topic 8 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic08/topic08_sgd_hashing_vowpal_wabbit.html">Vowpal Wabbit: Learning with Gigabytes of Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic08/videolecture08.html">Videolecture 8</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic08/assignment08_implement_sgd_regressor.html">Demo Assignment 8</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic08/assignment08_implement_sgd_regressor_solution.html">Demo Assignment 8 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic08/bonus_assignment08.html">Bonus Assignment 8</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 9</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../topic09/topic09_intro.html">Topic 9 Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic09/topic9_part1_time_series_python.html">Topic 9. Part 1. Time series analysis in Python</a></li>







<li class="toctree-l1"><a class="reference internal" href="../topic09/topic9_part2_facebook_prophet.html">Predicting the future with Facebook Prophet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic09/videolecture09.html">Videolecture 9</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic09/assignment09_time_series.html">Demo Assignment 9</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic09/assignment09_time_series_solution.html">Demo Assignment 9 Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic09/bonus_assignment09.html">Bonus Assignment 9</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Topic 10</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="topic10_intro.html">Topic 10 Intro</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Gradient boosting</a></li>
<li class="toctree-l1"><a class="reference internal" href="videolecture10.html">Videolecture 10</a></li>
<li class="toctree-l1"><a class="reference internal" href="assignment10_flight_delays_kaggle.html">Demo Assignment 10</a></li>
<li class="toctree-l1"><a class="reference internal" href="bonus_assignment10.html">Bonus Assignment 10</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About the course</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../extra/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extra/rating.html">Rating</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extra/resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extra/contributors.html">Contributors</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/Yorko/mlcourse.ai" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Yorko/mlcourse.ai/edit/main/mlcourse_ai_jupyter_book/book/topic10/topic10_gradient_boosting.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Yorko/mlcourse.ai/issues/new?title=Issue%20on%20page%20%2Fbook/topic10/topic10_gradient_boosting.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/book/topic10/topic10_gradient_boosting.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Topic 10. Gradient Boosting</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#article-outline">Article outline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction-and-history-of-boosting">1.  Introduction and history of boosting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#history-of-gbm">History of GBM</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gbm-algorithm">2. GBM algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ml-problem-statement">ML problem statement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#functional-gradient-descent">Functional gradient descent</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#friedman-s-classic-gbm-algorithm">Friedman’s classic GBM algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-by-step-example-how-gbm-works">Step-By-Step example: How GBM Works</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loss-functions">3. Loss functions</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#regression-loss-functions">Regression loss functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classification-loss-functions">Classification loss functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weights">Weights</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">4. Conclusion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#useful-resources">5. Useful resources</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="topic-10-gradient-boosting">
<span id="topic10"></span><h1><a class="toc-backref" href="#id1" role="doc-backlink">Topic 10. Gradient Boosting</a><a class="headerlink" href="#topic-10-gradient-boosting" title="Link to this heading">#</a></h1>
<img src="https://habrastorage.org/webt/ia/m9/zk/iam9zkyzqebnf_okxipihkgjwnw.jpeg" />
<p><strong><center><a class="reference external" href="https://mlcourse.ai">mlcourse.ai</a> – Open Machine Learning Course</strong> </center><br></p>
<p>Author: <a class="reference external" href="https://www.linkedin.com/in/natekin/">Alexey Natekin</a>, OpenDataScience founder, Machine Learning Evangelist. Translated and edited by <a class="reference external" href="https://www.linkedin.com/in/odaykhovskaya/">Olga Daykhovskaya</a>, <a class="reference external" href="https://www.linkedin.com/in/anastasiiamanokhina/">Anastasia Manokhina</a>, <a class="reference external" href="https://www.linkedin.com/in/egor-polusmak/">Egor Polusmak</a>, and <a class="reference external" href="https://www.linkedin.com/in/yuanyuanpao/">Yuanyuan Pao</a>. This material is subject to the terms and conditions of the <a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons CC BY-NC-SA 4.0</a> license. Free use is permitted for any non-commercial purpose.</p>
<img src='https://habrastorage.org/web/4a9/edb/082/4a9edb082408442ea47a12b75f19d122.jpg' align='right' width=40%>
<p>Today we are going to have a look at one of the most popular and practical machine learning algorithms: gradient boosting.</p>
<section id="article-outline">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Article outline</a><a class="headerlink" href="#article-outline" title="Link to this heading">#</a></h2>
<p>We recommend going over this article in the order described below, but feel free to jump around between sections.</p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#topic-10-gradient-boosting" id="id1">Topic 10. Gradient Boosting</a></p>
<ul>
<li><p><a class="reference internal" href="#article-outline" id="id2">Article outline</a></p></li>
<li><p><a class="reference internal" href="#introduction-and-history-of-boosting" id="id3">1.  Introduction and history of boosting</a></p>
<ul>
<li><p><a class="reference internal" href="#history-of-gbm" id="id4">History of GBM</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#gbm-algorithm" id="id5">2. GBM algorithm</a></p>
<ul>
<li><p><a class="reference internal" href="#ml-problem-statement" id="id6">ML problem statement</a></p></li>
<li><p><a class="reference internal" href="#functional-gradient-descent" id="id7">Functional gradient descent</a></p></li>
<li><p><a class="reference internal" href="#friedman-s-classic-gbm-algorithm" id="id8">Friedman’s classic GBM algorithm</a></p></li>
<li><p><a class="reference internal" href="#step-by-step-example-how-gbm-works" id="id9">Step-By-Step example: How GBM Works</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#loss-functions" id="id10">3. Loss functions</a></p>
<ul>
<li><p><a class="reference internal" href="#regression-loss-functions" id="id11">Regression loss functions</a></p></li>
<li><p><a class="reference internal" href="#classification-loss-functions" id="id12">Classification loss functions</a></p></li>
<li><p><a class="reference internal" href="#weights" id="id13">Weights</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#conclusion" id="id14">4. Conclusion</a></p></li>
<li><p><a class="reference internal" href="#useful-resources" id="id15">5. Useful resources</a></p></li>
</ul>
</li>
</ul>
</nav>
</section>
<section id="introduction-and-history-of-boosting">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">1.  Introduction and history of boosting</a><a class="headerlink" href="#introduction-and-history-of-boosting" title="Link to this heading">#</a></h2>
<p>Almost everyone in machine learning has heard about gradient boosting. Many data scientists include this algorithm in their data scientist’s toolbox because of the good results it yields on any given (unknown) problem.</p>
<p>Furthermore, XGBoost is often the standard recipe for <a class="reference external" href="https://github.com/dmlc/xgboost/blob/master/demo/README.md#usecases">winning</a> <a class="reference external" href="http://blog.kaggle.com/tag/xgboost/">ML competitions</a>. It is so popular that the idea of stacking XGBoosts has become a meme. Moreover, boosting is an important component in <a class="reference external" href="https://en.wikipedia.org/wiki/Learning_to_rank#Practical_usage_by_search_engines">many recommender systems</a>; sometimes, it is even considered a <a class="reference external" href="https://yandex.com/company/technologies/matrixnet/">brand</a>.
Let’s look at the history and development of boosting.</p>
<p>Boosting was born out of <a class="reference external" href="http://www.cis.upenn.edu/~mkearns/papers/boostnote.pdf">the question:</a> is it possible to get one strong model from a large amount of relatively weak and simple models? By saying “weak models”, we do not mean simple basic models like decision trees but models with poor accuracy performance, where poor is a little bit better than random.</p>
<p>A positive mathematical answer to this question was found (see <a class="reference external" href="http://rob.schapire.net/papers/strengthofweak.pdf">“The Strength of Weak Learnability”</a> by Robert Shapire), but it took a few years to develop fully functioning algorithms based on this solution e.g. AdaBoost. These algorithms take a greedy approach: first, they build a linear combination of simple models (basic algorithms) by re-weighing the input data. Then, the model (usually a decision tree) is built on earlier incorrectly predicted objects, which are now given larger weights.</p>
<spoiler title="More about AdaBoost">
Many machine learning courses study AdaBoost - the ancestor of GBM (Gradient Boosting Machine). However, since AdaBoost merged with GBM, it has become apparent that AdaBoost is just a particular variation of GBM.  
<p>The algorithm itself has a very clear visual interpretation and intuition for defining weights. Let’s have a look at the following toy classification problem where we are going to split the data between the trees of depth 1 (also known as ‘stumps’) on each iteration of AdaBoost. For the first two iterations, we have the following picture:</p>
<img src='https://habrastorage.org/web/d28/78f/7ba/d2878f7bad0340fc8002e5ba6d0879a5.jpg' width=70%>
<p>The size of point corresponds to its weight, which was assigned for an incorrect prediction.  On each iteration, we can see that these weights are growing – the stumps cannot cope with this problem. Although, if we take a weighted vote for the stumps, we will get the correct classifications:</p>
<img src='https://habrastorage.org/web/b2b/029/d89/b2b029d898f64bbbb158e15d29595969.png' width=70%>
<p>Pseudocode:</p>
<ul class="simple">
<li><p>Initialize sample weights <span class="math notranslate nohighlight">\(\Large w_i^{(0)} = \frac{1}{l}, i = 1, \dots, l\)</span>.</p></li>
<li><p>For all <span class="math notranslate nohighlight">\(t = 1, \dots, T\)</span></p>
<ul>
<li><p>Train base algo <span class="math notranslate nohighlight">\(\Large b_t\)</span>, let <span class="math notranslate nohighlight">\(\epsilon_t\)</span> be it’s training error.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Large \alpha_t = \frac{1}{2}ln\frac{1 - \epsilon_t}{\epsilon_t}\)</span>.</p></li>
<li><p>Update sample weights: <span class="math notranslate nohighlight">\(\Large w_i^{(t)} = w_i^{(t-1)} e^{-\alpha_t y_i b_t(x_i)}, i = 1, \dots, l\)</span>.</p></li>
<li><p>Normalize sample weights: <span class="math notranslate nohighlight">\(\Large w_0^{(t)} = \sum_{j = 1}^l w_j^{(t)}, w_i^{(t)} = \frac{w_i^{(t)}}{w_0^{(t)}}, i = 1, \dots, l\)</span>.</p></li>
</ul>
</li>
<li><p>Return <span class="math notranslate nohighlight">\(\sum_t^{T}\alpha_tb_t\)</span></p></li>
</ul>
<p><a class="reference external" href="https://www.youtube.com/watch?v=k4G2VCuOMMg">Here</a> is more detailed example of AdaBoost where, as we iterate, we can see the weights increase, especially on the border between classes.</p>
<p>AdaBoost works well, but <a class="reference external" href="https://www.cs.princeton.edu/courses/archive/spring07/cos424/papers/boosting-survey.pdf">the lack</a> of explanation for why the algorithm is successful sewed the seeds of doubt. Some considered it a super-algorithm, a silver bullet, but others were skeptical and believed AdaBoost was just overfitting.</p>
<p>The overfitting problem did indeed exist, especially when data had strong outliers. Therefore, in those types of problems, AdaBoost was unstable. Fortunately, a few professors in the statistics department at Stanford, who had created Lasso, Elastic Net, and Random Forest, started researching the algorithm. In 1999, Jerome Friedman came up with the generalization of boosting algorithms development - Gradient Boosting (Machine), also known as GBM. With this work, Friedman set up the statistical foundation for many algorithms providing the general approach of boosting for optimization in the functional space.</p>
<p>CART, bootstrap, and many other algorithms have originated from Stanford’s statistics department. In doing so, the department has solidified their names in future textbooks. These algorithms are very practical, and some recent works have yet to be widely adopted. For example, check out <a class="reference external" href="https://arxiv.org/abs/1308.2719">glinternet</a>.</p>
<p>Not many video recordings of Friedman are available. Although, there is a very interesting <a class="reference external" href="https://www.youtube.com/watch?v=8hupHmBVvb0">interview</a> with him about the creation of CART and how they solved statistics problems (which is similar to data analysis and data science today) more than 40 years ago.</p>
<p>There is also a great <a class="reference external" href="https://www.youtube.com/watch?v=zBk3PK3g-Fc">lecture</a> from Hastie, a retrospective on data analysis from one of the creators of methods that we use everyday.</p>
<p>In general, there has been a transition from engineering and algorithmic research to a full-fledged approach to building and studying algorithms. From a mathematical perspective, this is not a big change - we are still adding (or boosting) weak algorithms and enlarging our ensemble with gradual improvements for parts of the data where the model was inaccurate. But, this time, the next simple model is not just built on re-weighted objects but improves its approximation of the gradient of overall objective function. This concept greatly opens up our algorithms for imagination and extensions.</p>
<img src="https://habrastorage.org/webt/h2/v4/k9/h2v4k9r-4yn4jwvwz99fbss4ghi.png" />
<section id="history-of-gbm">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">History of GBM</a><a class="headerlink" href="#history-of-gbm" title="Link to this heading">#</a></h3>
<p>It took more than 10 years after the introduction of GBM for it to become an essential part of the data science toolbox.<br />
GBM was extended to apply to different statistics problems: GLMboost and GAMboost for strengthening already existing GAM models, CoxBoost for survival curves, and RankBoost and LambdaMART for ranking.<br />
Many realizations of GBM also appeared under different names and on different platforms: Stochastic GBM, GBDT (Gradient Boosted Decision Trees), GBRT (Gradient Boosted Regression Trees), MART (Multiple Additive Regression Trees), and more. In addition, the ML community was very segmented and dissociated, which made it hard to track just how widespread boosting had become.</p>
<p>At the same time, boosting had been actively used in search ranking. This problem was rewritten in terms of a loss function that penalizes errors in the output order, so it became convenient to simply insert it into GBM. AltaVista was one of the first companies who introduced boosting to ranking. Soon, the ideas spread to Yahoo, Yandex, Bing, etc. Once this happened, boosting became one of the main algorithms that was used not only in research but also in core technologies in industry.</p>
<p><img src='https://habrastorage.org/web/48a/ea4/fff/48aea4fffdbe4e5f9205ba81110e6061.jpg' align='right' width=30%> ML competitions, especially Kaggle, played a major role in boosting’s popularization. Now, researchers had a common platform where they could compete in different data science problems with large number of participants from around the world. With Kaggle, one could test new algorithms on the real data, giving algorithms an opportunity to “shine”, and provide full information in sharing model performance results across competition data sets. This is exactly what happened to boosting when it was used at <a class="reference external" href="http://blog.kaggle.com/2011/12/21/score-xavier-conort-on-coming-second-in-give-me-some-credit/">Kaggle</a> (check interviews with Kaggle winners starting from 2011 who mostly used boosting). The <a class="reference external" href="https://github.com/dmlc/xgboost">XGBoost</a> library quickly gained popularity after its appearance. XGBoost is not a new, unique algorithm; it is just an extremely effective realization of classic GBM with additional heuristics.</p>
<p>This algorithm has gone through very typical path for ML algorithms today: mathematical problem and algorithmic crafts to successful practical applications and mass adoption years after its first appearance.</p>
</section>
</section>
<section id="gbm-algorithm">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">2. GBM algorithm</a><a class="headerlink" href="#gbm-algorithm" title="Link to this heading">#</a></h2>
<section id="ml-problem-statement">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">ML problem statement</a><a class="headerlink" href="#ml-problem-statement" title="Link to this heading">#</a></h3>
<p>We are going to solve the problem of function approximation in a general supervised learning setting. We have a set of features <span class="math notranslate nohighlight">\( \large x \)</span> and target variables <span class="math notranslate nohighlight">\(\large y, \large \left\{ (x_i, y_i) \right\}_{i=1, \ldots,n}\)</span> which we use to restore the dependence <span class="math notranslate nohighlight">\(\large y = f(x) \)</span>. We restore the dependence by approximating <span class="math notranslate nohighlight">\( \large \hat{f}(x) \)</span> and by understanding which approximation is better when we use the loss function <span class="math notranslate nohighlight">\( \large L(y,f) \)</span>, which we want to minimize: <span class="math notranslate nohighlight">\( \large y \approx \hat{f}(x), \large \hat{f}(x) = \underset{f(x)}{\arg\min} \ L(y,f(x)) \)</span>.</p>
<img src='../../_static/img/topic10_help_with_func_compressed.png'  align='center'>
<p>At this moment, we do not make any assumptions regarding the type of dependence <span class="math notranslate nohighlight">\( \large f(x) \)</span>, the model of our approximation <span class="math notranslate nohighlight">\( \large \hat{f}(x) \)</span>, or the distribution of the target variable <span class="math notranslate nohighlight">\( \large y \)</span>. We only expect the function <span class="math notranslate nohighlight">\( \large L(y,f) \)</span> to be differentiable. Our approach is very general: we define <span class="math notranslate nohighlight">\( \large \hat {f}(x) \)</span> by minimizing the loss:</p>
<div class="math notranslate nohighlight">
\[\large  \hat{f}(x) = \underset{f(x)}{\arg\min} \ \mathbb {E} _{x,y}[L(y,f(x))]\]</div>
<p>Unfortunately, the number of functions <span class="math notranslate nohighlight">\( \large f(x) \)</span> is not just large, but its functional space is infinite-dimensional. That is why it is acceptable for us to limit the search space by some family of functions <span class="math notranslate nohighlight">\( \large f(x, \theta), \theta \in \mathbb{R}^d \)</span>. This simplifies the objective a lot because now we have a solvable optimization of parameter values:
<span class="math notranslate nohighlight">\(\large \hat{f}(x) = f(x, \hat{\theta}),\)</span></p>
<div class="math notranslate nohighlight">
\[\large \hat{\theta} = \underset{\theta}{\arg\min} \ \mathbb {E} _{x,y}[L(y,f(x,\theta))]\]</div>
<p>Simple analytical solutions for finding the optimal parameters <span class="math notranslate nohighlight">\( \large \hat{\theta} \)</span> often do not exist, so the parameters are usually approximated iteratively. To start, we write down the empirical loss function <span class="math notranslate nohighlight">\( \large L_{\theta}(\hat{\theta}) \)</span> that will allow us to evaluate our parameters using our data. Additionally, let’s write out our approximation <span class="math notranslate nohighlight">\( \large \hat{\theta} \)</span> for a number of <span class="math notranslate nohighlight">\( \large M \)</span> iterations as a sum:</p>
<p><span class="math notranslate nohighlight">\( \large \hat{\theta} = \sum_{i = 1}^M \hat{\theta_i}, \\
\large L_{\theta}(\hat{\theta}) =  \sum_{i = 1}^N L(y_i,f(x_i, \hat{\theta}))\)</span></p>
<p>Then, the only thing left is to find a suitable, iterative algorithm to minimize <span class="math notranslate nohighlight">\(\large L_{\theta}(\hat{\theta})\)</span>. Gradient descent is the simplest and most frequently used option. We define the gradient as <span class="math notranslate nohighlight">\(\large \nabla L_{\theta}(\hat{\theta})\)</span> and add our iterative evaluations <span class="math notranslate nohighlight">\(\large \hat{\theta_i}\)</span> to it (since we are minimizing the loss, we add the minus sign). Our last step is to initialize our first approximation <span class="math notranslate nohighlight">\(\large \hat{\theta_0}\)</span> and choose the number of iterations <span class="math notranslate nohighlight">\(\large M\)</span>. Let’s review the steps for this inefficient and naive algorithm for approximating <span class="math notranslate nohighlight">\(\large \hat{\theta}\)</span>:</p>
<ol class="arabic simple">
<li><p>Define the initial approximation of the parameters <span class="math notranslate nohighlight">\(\large \hat{\theta} = \hat{\theta_0}\)</span></p></li>
<li><p>For every iteration <span class="math notranslate nohighlight">\(\large t = 1, \dots, M\)</span> repeat steps 3-7:</p></li>
<li><p>Calculate the gradient of the loss function <span class="math notranslate nohighlight">\(\large \nabla L_{\theta}(\hat{\theta})\)</span> for the current approximation <span class="math notranslate nohighlight">\(\large \hat{\theta}\)</span>
<span class="math notranslate nohighlight">\(\large \nabla L_{\theta}(\hat{\theta}) = \left[\frac{\partial L(y, f(x, \theta))}{\partial \theta}\right]_{\theta = \hat{\theta}}\)</span></p></li>
<li><p>Set the current iterative approximation <span class="math notranslate nohighlight">\(\large \hat{\theta_t}\)</span> based on the calculated gradient
<span class="math notranslate nohighlight">\(\large \hat{\theta_t} \leftarrow −\nabla L_{\theta}(\hat{\theta})\)</span></p></li>
<li><p>Update the approximation of the parameters <span class="math notranslate nohighlight">\(\large \hat{\theta}\)</span>:
<span class="math notranslate nohighlight">\(\large \hat{\theta} \leftarrow \hat{\theta} + \hat{\theta_t} = \sum_{i = 0}^t \hat{\theta_i} \)</span></p></li>
<li><p>Save the result of approximation <span class="math notranslate nohighlight">\(\large \hat{\theta}\)</span>:
<span class="math notranslate nohighlight">\(\large \hat{\theta} = \sum_{i = 0}^M \hat{\theta_i} \)</span></p></li>
<li><p>Use the function that was found <span class="math notranslate nohighlight">\(\large \hat{f}(x) = f(x, \hat{\theta})\)</span></p></li>
</ol>
<img src='https://habrastorage.org/web/2b5/5d6/90d/2b55d690d99e4ec0976b360aae6ce4df.jpg'   align='center'>
</section>
<section id="functional-gradient-descent">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Functional gradient descent</a><a class="headerlink" href="#functional-gradient-descent" title="Link to this heading">#</a></h3>
<p>Let’s imagine for a second that we can perform optimization in the function space and iteratively search for the approximations <span class="math notranslate nohighlight">\(\large \hat{f}(x)\)</span> as functions themselves. We will express our approximation as a sum of incremental improvements, each being a function. For convenience, we will immediately start with the sum from the initial approximation <span class="math notranslate nohighlight">\(\large \hat{f_0}(x)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\large \hat{f}(x) = \sum_{i = 0}^M \hat{f_i}(x)\]</div>
<p>Nothing has happened yet; we have only decided that we will search for our approximation <span class="math notranslate nohighlight">\(\large \hat{f}(x)\)</span> not as a big model with plenty of parameters (as an example, neural network), but as a sum of functions, pretending we move in functional space.</p>
<p>In order to accomplish this task, we need to limit our search by some function family <span class="math notranslate nohighlight">\(\large \hat{f}(x) = h(x, \theta)\)</span>. There are a few issues here – first of all, the sum of models can be more complicated than any model from this family; secondly, the general objective is still in functional space. Let’s note that, on every step, we will need to select an optimal coefficient <span class="math notranslate nohighlight">\(\large \rho \in \mathbb{R}\)</span>. For step <span class="math notranslate nohighlight">\(\large t\)</span>, the problem is the following:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\large \hat{f}(x) = \sum_{i = 0}^{t-1} \hat{f_i}(x), \\
\large (\rho_t,\theta_t) = \underset{\rho,\theta}{\arg\min} \ \mathbb {E} _{x,y}[L(y,\hat{f}(x) +  \rho \cdot h(x, \theta))], \\
\large \hat{f_t}(x) = \rho_t \cdot h(x, \theta_t)\end{split}\]</div>
<p>Here is where the magic happens. We have defined all of our objectives in general terms, as if we could have trained any kind of model <span class="math notranslate nohighlight">\(\large h(x, \theta)\)</span> for any type of loss functions <span class="math notranslate nohighlight">\(\large L(y, f(x, \theta))\)</span>. In practice, this is extremely difficult, but, fortunately, there is a simple way to solve this task.</p>
<p>Knowing the expression of loss function’s gradient, we can calculate its value on our data. So, let’s train the models such that our predictions will be more correlated with this gradient (with a minus sign). In other words, we will use least squares to correct the predictions with these residuals. For classification, regression, and ranking tasks, we will minimize the squared difference between pseudo-residuals <span class="math notranslate nohighlight">\(\large r\)</span> and our predictions. For step <span class="math notranslate nohighlight">\(\large t\)</span>, the final problem looks like the following:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \large \hat{f}(x) = \sum_{i = 0}^{t-1} \hat{f_i}(x), \\
\large r_{it} = -\left[\frac{\partial L(y_i, f(x_i))}{\partial f(x_i)}\right]_{f(x)=\hat{f}(x)}, \quad \mbox{for } i=1,\ldots,n ,\\
\large \theta_t = \underset{\theta}{\arg\min} \ \sum_{i = 1}^{n} (r_{it} - h(x_i, \theta))^2, \\
\large \rho_t = \underset{\rho}{\arg\min} \ \sum_{i = 1}^{n} L(y_i, \hat{f}(x_i) + \rho \cdot h(x_i, \theta_t))\end{split}\]</div>
<img src='../../_static/img/topic10_regression_for_everybody.jpg'   align='center' width=60%>
</section>
<section id="friedman-s-classic-gbm-algorithm">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Friedman’s classic GBM algorithm</a><a class="headerlink" href="#friedman-s-classic-gbm-algorithm" title="Link to this heading">#</a></h3>
<p>We can now define the classic GBM algorithm suggested by Jerome Friedman in 1999. It is a supervised algorithm that has the following components:</p>
<ul class="simple">
<li><p>dataset <span class="math notranslate nohighlight">\(\large \left\{ (x_i, y_i) \right\}_{i=1, \ldots,n}\)</span>;</p></li>
<li><p>number of iterations <span class="math notranslate nohighlight">\(\large M\)</span>;</p></li>
<li><p>choice of loss function <span class="math notranslate nohighlight">\(\large L(y, f)\)</span> with a defined gradient;</p></li>
<li><p>choice of function family of base algorithms <span class="math notranslate nohighlight">\(\large h(x, \theta)\)</span> with the training procedure;</p></li>
<li><p>additional hyperparameters <span class="math notranslate nohighlight">\(\large h(x, \theta)\)</span> (for example, in decision trees, the tree depth);</p></li>
</ul>
<p>The only thing left is the initial approximation <span class="math notranslate nohighlight">\(\large f_0(x)\)</span>. For simplicity, for an initial approximation, a constant value <span class="math notranslate nohighlight">\(\large \gamma\)</span> is used. The constant value, as well as the optimal coefficient <span class="math notranslate nohighlight">\(\large \rho \)</span>, are identified via binary search or another line search algorithm over the initial loss function (not a gradient). So, we have our GBM algorithm described as follows:</p>
<ol class="arabic simple">
<li><p>Initialize GBM with constant value <span class="math notranslate nohighlight">\(\large \hat{f}(x) = \hat{f}_0, \hat{f}_0 = \gamma,  \gamma \in \mathbb{R}\)</span>
<span class="math notranslate nohighlight">\(\large \hat{f}_0 = \underset{\gamma}{\arg\min} \ \sum_{i = 1}^{n} L(y_i, \gamma)\)</span></p></li>
<li><p>For each iteration <span class="math notranslate nohighlight">\(\large t = 1, \dots, M\)</span>, repeat:</p></li>
<li><p>Calculate pseudo-residuals <span class="math notranslate nohighlight">\(\large r_t\)</span>
<span class="math notranslate nohighlight">\(\large r_{it} = -\left[\frac{\partial L(y_i, f(x_i))}{\partial f(x_i)}\right]_{f(x)=\hat{f}(x)}, \quad \mbox{for } i=1,\ldots,n\)</span></p></li>
<li><p>Build new base algorithm <span class="math notranslate nohighlight">\(\large h_t(x)\)</span> as regression on pseudo-residuals <span class="math notranslate nohighlight">\(\large \left\{ (x_i, r_{it}) \right\}_{i=1, \ldots,n}\)</span></p></li>
<li><p>Find optimal coefficient <span class="math notranslate nohighlight">\(\large \rho_t \)</span> at <span class="math notranslate nohighlight">\(\large h_t(x)\)</span> regarding initial loss function
<span class="math notranslate nohighlight">\(\large \rho_t = \underset{\rho}{\arg\min} \ \sum_{i = 1}^{n} L(y_i, \hat{f}(x_i) +  \rho \cdot h(x_i, \theta))\)</span></p></li>
<li><p>Save <span class="math notranslate nohighlight">\(\large \hat{f_t}(x) = \rho_t \cdot h_t(x)\)</span></p></li>
<li><p>Update current approximation <span class="math notranslate nohighlight">\(\large \hat{f}(x)\)</span>
<span class="math notranslate nohighlight">\(\large \hat{f}(x) \leftarrow \hat{f}(x) + \hat{f_t}(x) = \sum_{i = 0}^{t} \hat{f_i}(x)\)</span></p></li>
<li><p>Compose final GBM model <span class="math notranslate nohighlight">\(\large \hat{f}(x)\)</span>
<span class="math notranslate nohighlight">\(\large \hat{f}(x) = \sum_{i = 0}^M \hat{f_i}(x) \)</span></p></li>
<li><p>Conquer Kaggle and the rest of the world</p></li>
</ol>
</section>
<section id="step-by-step-example-how-gbm-works">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Step-By-Step example: How GBM Works</a><a class="headerlink" href="#step-by-step-example-how-gbm-works" title="Link to this heading">#</a></h3>
<p>Let’s see an example of how GBM works. In this toy example, we will restore a noisy function <span class="math notranslate nohighlight">\(\large y = cos(x) + \epsilon, \epsilon \sim \mathcal{N}(0, \frac{1}{5}), x \in [-5,5]\)</span>.</p>
<img src='https://habrastorage.org/web/9fe/04d/7ba/9fe04d7ba5a645d49fc6aa3e875c8c41.jpg'   align='center'>
<p>This is a regression problem with a real-valued target, so we will choose to use the mean squared error loss function. We will generate 300 pairs of observations and approximate them with decision trees of depth 2. Let’s put together everything we need to use GBM:</p>
<ul class="simple">
<li><p>Toy data <span class="math notranslate nohighlight">\(\large \left\{ (x_i, y_i) \right\}_{i=1, \ldots,300}\)</span> ✓</p></li>
<li><p>Number of iterations <span class="math notranslate nohighlight">\(\large M = 3\)</span> ✓;</p></li>
<li><p>The mean squared error loss function <span class="math notranslate nohighlight">\(\large L(y, f) = (y-f)^2\)</span> ✓</p></li>
<li><p>Gradient of <span class="math notranslate nohighlight">\(\large L(y, f) = L_2\)</span> loss is just residuals <span class="math notranslate nohighlight">\(\large r = (y - f)\)</span> ✓;</p></li>
<li><p>Decision trees as base algorithms <span class="math notranslate nohighlight">\(\large h(x)\)</span> ✓;</p></li>
<li><p>Hyperparameters of the decision trees: trees depth is equal to 2 ✓;</p></li>
</ul>
<p>For the mean squared error, both initialization <span class="math notranslate nohighlight">\(\large \gamma\)</span> and coefficients <span class="math notranslate nohighlight">\(\large \rho_t\)</span> are simple. We will initialize GBM with the average value <span class="math notranslate nohighlight">\(\large \gamma = \frac{1}{n} \cdot \sum_{i = 1}^n y_i\)</span>, and set all coefficients <span class="math notranslate nohighlight">\(\large \rho_t\)</span> to 1.</p>
<p>We will run GBM and draw two types of graphs: the current approximation <span class="math notranslate nohighlight">\(\large \hat{f}(x)\)</span> (blue graph) and every tree <span class="math notranslate nohighlight">\(\large \hat{f_t}(x)\)</span> built on its pseudo-residuals (green graph). The graph’s number corresponds to the iteration number:</p>
<img src='https://habrastorage.org/web/edb/328/98a/edb32898ad014d8d95782759d11f63fb.png'   align='center'>
<p>By the second iteration, our trees have recovered the basic form of the function. However, at the first iteration, we see that the algorithm has built only the “left branch” of the function (<span class="math notranslate nohighlight">\(\large x \in [-5, -4]\)</span>). This was due to the fact that our trees simply did not have enough depth to build a symmetrical branch at once, and it focused on the left branch with the larger error. Therefore, the right branch appeared only after the second iteration.</p>
<p>The rest of the process goes as expected – on every step, our pseudo-residuals decreased, and GBM approximated the original function better and better with each iteration. However, by construction, trees cannot approximate a continuous function, which means that GBM is not ideal in this example. To play with GBM function approximations, you can use the awesome interactive demo in this blog called <a class="reference external" href="http://arogozhnikov.github.io/2016/06/24/gradient_boosting_explained.html">Brilliantly wrong</a>:</p>
<img src='https://habrastorage.org/web/779/3e0/e66/7793e0e66b7d4871b6391a94cd5d4cf2.jpg'   align='center'>
</section>
</section>
<section id="loss-functions">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">3. Loss functions</a><a class="headerlink" href="#loss-functions" title="Link to this heading">#</a></h2>
<p>If we want to solve a classification problem instead of regression, what would change? We only need to choose a suitable loss function <span class="math notranslate nohighlight">\(\large L(y, f)\)</span>. This is the most important, high-level moment that determines exactly how we will optimize and what characteristics we can expect in the final model.</p>
<p>As a rule, we do not need to invent this ourselves – researchers have already done it for us. Today, we will explore loss functions for the two most common objectives: regression <span class="math notranslate nohighlight">\(\large y \in \mathbb{R}\)</span> and binary classification <span class="math notranslate nohighlight">\(\large y \in \left\{-1, 1\right\}\)</span>.</p>
<section id="regression-loss-functions">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Regression loss functions</a><a class="headerlink" href="#regression-loss-functions" title="Link to this heading">#</a></h3>
<p>Let’s start with a regression problem for <span class="math notranslate nohighlight">\(\large y \in \mathbb{R}\)</span>. In order to choose the appropriate loss function, we need to consider which of the properties of the conditional distribution <span class="math notranslate nohighlight">\(\large (y|x)\)</span> we want to restore. The most common options are:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\large L(y, f) = (y - f)^2\)</span> a.k.a. <span class="math notranslate nohighlight">\(\large L_2\)</span> loss or Gaussian loss. It is the classical conditional mean, which is the simplest and most common case. If we do not have any additional information or requirements for a model to be robust, we can use the Gaussian loss.</p></li>
<li><p><span class="math notranslate nohighlight">\(\large L(y, f) = |y - f|\)</span> a.k.a. <span class="math notranslate nohighlight">\(\large L_1\)</span> loss or Laplacian loss. At the first glance, this function does not seem to be differentiable, but it actually defines the conditional median. Median, as we know, is robust to outliers, which is why this loss function is better in some cases. The penalty for big variations is not as heavy as it is in <span class="math notranslate nohighlight">\(\large L_2\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\( \large \begin{equation}  L(y, f) =\left\{   \begin{array}{&#64;{}ll&#64;{}}     (1 - \alpha) \cdot |y - f|, &amp; \text{if}\ y-f \leq 0 \\     \alpha \cdot |y - f|, &amp; \text{if}\ y-f &gt;0  \end{array}\right. \end{equation}, \alpha \in (0,1)
\)</span> a.k.a. <span class="math notranslate nohighlight">\(\large L_q\)</span> loss or Quantile loss.  Instead of median, it uses quantiles. For example, <span class="math notranslate nohighlight">\(\large \alpha = 0.75\)</span> corresponds to the 75%-quantile. We can see that this function is asymmetric and penalizes the observations which are on the right side of the defined quantile.</p></li>
</ul>
<img src='https://habrastorage.org/web/6d5/e3a/09c/6d5e3a09c703491b947fde851e412ac0.png' width=60%>
<p>Let’s use loss function <span class="math notranslate nohighlight">\(\large L_q\)</span> on our data. The goal is to restore the conditional 75%-quantile of cosine. Let us put everything together for GBM:</p>
<ul class="simple">
<li><p>Toy data <span class="math notranslate nohighlight">\(\large \left\{ (x_i, y_i) \right\}_{i=1, \ldots,300}\)</span> ✓</p></li>
<li><p>A number of iterations <span class="math notranslate nohighlight">\(\large M = 3\)</span> ✓;</p></li>
<li><p>Loss function for quantiles <span class="math notranslate nohighlight">\( \large \begin{equation}   L_{0.75}(y, f) =\left\{
\begin{array}{&#64;{}ll&#64;{}}    0.25 \cdot |y - f|, &amp; \text{if}\ y-f \leq 0 \\     0.75 \cdot |y - f|, &amp; \text{if}\ y-f &gt;0   \end{array}\right. \end{equation} \)</span> ✓;</p></li>
<li><p>Gradient <span class="math notranslate nohighlight">\(\large L_{0.75}(y, f)\)</span> - function weighted by <span class="math notranslate nohighlight">\(\large \alpha = 0.75\)</span>. We are going to train tree-based model for classification:
<span class="math notranslate nohighlight">\(\large r_{i} = -\left[\frac{\partial L(y_i, f(x_i))}{\partial f(x_i)}\right]_{f(x)=\hat{f}(x)} = \)</span>
<span class="math notranslate nohighlight">\(\large = \alpha I(y_i &gt; \hat{f}(x_i) ) - (1 - \alpha)I(y_i \leq \hat{f}(x_i) ), \quad \mbox{for } i=1,\ldots,300\)</span> ✓;</p></li>
<li><p>Decision tree as a basic algorithm <span class="math notranslate nohighlight">\(\large h(x)\)</span> ✓;</p></li>
<li><p>Hyperparameter of trees: depth =  2 ✓;</p></li>
</ul>
<p>For our initial approximation, we will take the needed quantile of <span class="math notranslate nohighlight">\(\large y\)</span>. However, we do not know anything about optimal coefficients <span class="math notranslate nohighlight">\(\large \rho_t\)</span>, so we’ll use standard line search. The results are the following:</p>
<img src='https://habrastorage.org/web/0e6/7dd/614/0e67dd614076499e91c8c4238457ae4d.png'   align='center'>
<p>We can observe that, on each iteration, <span class="math notranslate nohighlight">\(\large r_{i} \)</span> take only 2 possible values, but GBM is still able to restore our initial function.</p>
<p>The overall results of GBM with quantile loss function are the same as the results with quadratic loss function offset by <span class="math notranslate nohighlight">\(\large \approx 0.135\)</span>. But if we were to use the 90%-quantile, we would not have enough data due to the fact that classes would become unbalanced. We need to remember this when we deal with non-standard problems.</p>
<p><em>“A few words on regression loss functions”</em></p>
<p>For regression tasks, many loss functions have been developed, some of them with extra properties. For example, they can be robust like in the <a class="reference external" href="https://en.wikipedia.org/wiki/Huber_loss">Huber loss function</a>. For a small number of outliers, the loss function works as <span class="math notranslate nohighlight">\(\large L_2\)</span>, but after a defined threshold, the function changes to <span class="math notranslate nohighlight">\(\large L_1\)</span>. This allows for decreasing the effect of outliers and focusing on the overall picture.</p>
<p>We can illustrate this with the following example. Data is generated from the function  <span class="math notranslate nohighlight">\(\large y = \frac{sin(x)}{x}\)</span> with added noise, a mixture from normal and Bernoulli distributions. We show the functions on graphs A-D and the relevant GBM on F-H (graph E represents the initial function):</p>
<p><img src='https://habrastorage.org/web/130/05b/222/13005b222e8a4eb68c3936216c05e276.jpg'   align='center'> <a class="reference external" href="https://habrastorage.org/web/130/05b/222/13005b222e8a4eb68c3936216c05e276.jpg">Original size</a>.</p>
<p>In this example, we used splines as the base algorithm. See, it does not always have to be trees for boosting?</p>
<p>We can clearly see the difference between the functions <span class="math notranslate nohighlight">\(\large L_2\)</span>, <span class="math notranslate nohighlight">\(\large L_1\)</span>, and Huber loss. If we choose optimal parameters for the Huber loss, we can get the best possible approximation among all our options. The difference can be seen as well in the 10%, 50%, and 90%-quantiles.</p>
<p>Unfortunately, Huber loss function is supported only by very few popular libraries/packages; h2o supports it, but XGBoost does not. It is relevant to other things that are more exotic like <a class="reference external" href="https://www.slideshare.net/charthur/quantile-and-expectile-regression">conditional expectiles</a>, but it may still be interesting knowledge.</p>
</section>
<section id="classification-loss-functions">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Classification loss functions</a><a class="headerlink" href="#classification-loss-functions" title="Link to this heading">#</a></h3>
<p>Now, let’s look at the binary classification problem <span class="math notranslate nohighlight">\(\large y \in \left\{-1, 1\right\}\)</span>. We saw that GBM can even optimize non-differentiable loss functions. Technically, it is possible to solve this problem with a regression <span class="math notranslate nohighlight">\(\large L_2\)</span> loss, but it wouldn’t be correct.</p>
<p>The distribution of the target variable requires us to use log-likelihood, so we need to have different loss functions for targets multiplied by their predictions:  <span class="math notranslate nohighlight">\(\large y \cdot f\)</span>. The most common choices would be the following:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\large L(y, f) = log(1 + exp(-2yf))\)</span> a.k.a. Logistic loss or Bernoulli loss. This has an interesting property that penalizes even correctly predicted classes, which helps not only helps to optimize loss but also to move the classes apart further, even if all classes are predicted correctly.</p></li>
<li><p><span class="math notranslate nohighlight">\(\large L(y, f) = exp(-yf)\)</span> a.k.a. AdaBoost loss. The classic AdaBoost is equivalent to GBM with this loss function. Conceptually, this function is very similar to logistic loss, but it has a bigger exponential penalization if the prediction is wrong.</p></li>
</ul>
<img src='https://habrastorage.org/web/bf5/9de/dcf/bf59dedcfd9d49b18e89ce342b09ce69.png' width=60%>
<p>Let’s generate some new toy data for our classification problem. As a basis, we will take our noisy cosine, and we will use the sign function for classes of the target variable. Our toy data looks like the following (jitter-noise is added for clarity):</p>
<img src='https://habrastorage.org/web/e72/513/78b/e7251378bf6d459ab1aeea7a1f1996a1.jpg'>
<p>We will use logistic loss to look for what we actually boost. So, again, we put together what we will use for GBM:</p>
<ul class="simple">
<li><p>Toy data <span class="math notranslate nohighlight">\(\large \left\{ (x_i, y_i) \right\}_{i=1, \ldots,300}, y_i \in \left\{-1, 1\right\}\)</span> ✓</p></li>
<li><p>Number of iterations <span class="math notranslate nohighlight">\(\large M = 3\)</span> ✓;</p></li>
<li><p>Logistic loss as the loss function, its gradient is computed the following way:
<span class="math notranslate nohighlight">\(\large r_{i} = \frac{2 \cdot y_i}{1 + exp(2 \cdot y_i \cdot \hat{f}(x_i)) }, \quad \mbox{for } i=1,\ldots,300\)</span> ✓;</p></li>
<li><p>Decision trees as base algorithms <span class="math notranslate nohighlight">\(\large h(x)\)</span> ✓;</p></li>
<li><p>Hyperparameters of the decision trees: tree’s depth is equal to 2 ✓;</p></li>
</ul>
<p>This time, the initialization of the algorithm is a little bit harder. First, our classes are imbalanced  (63% versus 37%). Second, there is no known analytical formula for the initialization of our loss function, so we have to look for <span class="math notranslate nohighlight">\(\large \hat{f_0} = \gamma\)</span> via search:</p>
<img src='https://habrastorage.org/web/f8a/054/702/f8a05470271448d9bc0d4dc3e524a571.png' width=60%>
<p>Our optimal initial approximation is around -0.273. You could have guessed that it was negative because it is more profitable to predict everything as the most popular class, but there is no formula for the exact value. Now let’s finally start GBM, and look what actually happens under the hood:</p>
<img src='https://habrastorage.org/web/7b4/ab0/5fa/7b4ab05fa0a543bfad94950e47f91568.png'   align='center'>
<p>The algorithm successfully restored the separation between our classes. You can see how the “lower” areas are separating because the trees are more confident in the correct prediction of the negative class and how the two steps of mixed classes are forming. It is clear that we have a lot of correctly classified observations and some amount of observations with large errors that appeared due to the noise in the data.</p>
</section>
<section id="weights">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Weights</a><a class="headerlink" href="#weights" title="Link to this heading">#</a></h3>
<p>Sometimes, there is a situation where we want a more specific loss function for our problem. For example, in financial time series, we may want to give bigger weight to large movements in the time series; for churn prediction, it is more useful to predict the churn of clients with high LTV (or lifetime value: how much money a client will bring in the future).</p>
<img src='https://habrastorage.org/web/0c0/ad0/3a4/0c0ad03a4c4b46bfa5bcd5101678c9c4.jpg'   align='center'>
<p>The statistical warrior would invent their own loss function, write out the gradient for it (for more effective training, include the Hessian), and carefully check whether this function satisfies the required properties. However, there is a high probability of making a mistake somewhere, running up against computational difficulties, and spending an inordinate amount of time on research.</p>
<p>In lieu of this, a very simple instrument was invented (which is rarely remembered in practice): weighing observations and assigning weight functions. The simplest example of such weighting is the setting of weights for class balance. In general, if we know that some subset of data, both in the input variables <span class="math notranslate nohighlight">\(\large x\)</span> and in the target variable <span class="math notranslate nohighlight">\(\large y\)</span>, has greater importance for our model, then we just assign them a larger weight <span class="math notranslate nohighlight">\(\large w(x,y)\)</span>. The main goal is to fulfill the general requirements for weights:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \large w_i \in \mathbb{R}, \\
\large w_i \geq 0 \quad \mbox{for } i=1,\ldots,n, \\
\large \sum_{i = 1}^n w_i &gt; 0 \end{split}\]</div>
<p>Weights can significantly reduce the time spent adjusting the loss function for the task we are solving and also encourages experiments with the target models’ properties. Assigning these weights is entirely a function of creativity. We simply add scalar weights:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \large L_{w}(y,f) = w \cdot L(y,f), \\
\large r_{it} =   - w_i \cdot \left[\frac{\partial L(y_i, f(x_i))}{\partial f(x_i)}\right]_{f(x)=\hat{f}(x)}, \quad \mbox{for } i=1,\ldots,n \end{split}\]</div>
<p>It is clear that, for arbitrary weights, we do not know the statistical properties of our model. Often, linking the weights to the values <span class="math notranslate nohighlight">\(\large y\)</span> can be too complicated. For example, the usage of weights proportional to <span class="math notranslate nohighlight">\(\large |y|\)</span> in <span class="math notranslate nohighlight">\(\large L_1\)</span> loss function is not equivalent to <span class="math notranslate nohighlight">\(\large L_2\)</span> loss because the gradient will not take into account the values of the predictions themselves: <span class="math notranslate nohighlight">\(\large \hat{f}(x)\)</span>.</p>
<p>We mention all of this so that we can understand our possibilities better. Let’s create some very exotic weights for our toy data. We will define a strongly asymmetric weight function as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \large \begin{equation} w(x) =\left\{   \begin{array}{&#64;{}ll&#64;{}}     0.1, &amp; \text{if}\ x \leq 0 \\     0.1 + |cos(x)|, &amp; \text{if}\ x &gt;0 \end{array}\right. \end{equation} \end{split}\]</div>
<img src='https://habrastorage.org/web/8c2/1b1/aa4/8c21b1aa47134f7aa46b15ef910369b2.png'   align='center'>
<p>With these weights, we expect to get two properties: less detailing for negative values of <span class="math notranslate nohighlight">\(\large x\)</span> and the form of the function, similar to the initial cosine. We take the other GBM’s tunings from our previous example with classification including the line search for optimal coefficients. Let’s look what we’ve got:</p>
<img src='https://habrastorage.org/web/afc/cca/72a/afccca72a0774990b685de37b0fe9d9f.png'   align='center'>
<p>We achieved the result that we expected. First, we can see how strongly the pseudo-residuals differ; on the initial iteration, they look almost like the original cosine. Second, the left part of the function’s graph was often ignored in favor of the right one, which had larger weights. Third, the function that we got on the third iteration received enough attention and started looking similar to the original cosine (also started to slightly overfit).</p>
<p>Weights are a powerful but risky tool that we can use to control the properties of our model. If you want to optimize your loss function, it is worth trying to solve a more simple problem first but add weights to the observations at your discretion.</p>
</section>
</section>
<section id="conclusion">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">4. Conclusion</a><a class="headerlink" href="#conclusion" title="Link to this heading">#</a></h2>
<p>Today, we learned the theory behind gradient boosting. GBM is not just some specific algorithm but a common methodology for building ensembles of models. In addition, this methodology is sufficiently flexible and expandable – it is possible to train a large number of models, taking into consideration different loss-functions with a variety of weighting functions.</p>
<p>Practice and ML competitions show that, in standard problems (except for image, audio, and very sparse data), GBM is often the most effective algorithm (not to mention stacking and high-level ensembles, where GBM is almost always a part of them).  Also, there are many adaptations of GBM <a class="reference external" href="https://arxiv.org/abs/1603.04119">for Reinforcement Learning</a> (Minecraft, ICML 2016). By the way, the Viola-Jones algorithm, which is still used in computer vision, <a class="reference external" href="https://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework#Learning_algorithm">is based on AdaBoost</a>.</p>
<p>In this article, we intentionally omitted questions concerning GBM’s regularization, stochasticity, and hyper-parameters. It was not accidental that we used a small number of iterations <span class="math notranslate nohighlight">\(\large M = 3\)</span> throughout. If we used 30 trees instead of 3 and trained the GBM as described, the result would not be that predictable:</p>
<img src='../../_static/img/topic10_good_fit.png'   align='center' width=60%>
<img src='../../_static/img/topic10_overfitting.png'   align='center' width=60%>
<img src='https://habrastorage.org/web/27f/0f5/3be/27f0f53be9424cb1afaffb9a0e32909f.jpg'   align='center'>
<p><a class="reference external" href="http://arogozhnikov.github.io/2016/07/05/gradient_boosting_playground.html">Interactive demo</a></p>
</section>
<section id="useful-resources">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">5. Useful resources</a><a class="headerlink" href="#useful-resources" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Main course <a class="reference external" href="https://mlcourse.ai">site</a>, <a class="reference external" href="https://github.com/Yorko/mlcourse.ai">course repo</a>, and YouTube <a class="reference external" href="https://www.youtube.com/watch?v=QKTuw4PNOsU&amp;amp;list=PLVlY_7IJCMJeRfZ68eVfEcu-UcN9BbwiX">channel</a></p></li>
<li><p>Course materials as a <a class="reference external" href="https://www.kaggle.com/kashnitsky/mlcourse">Kaggle Dataset</a></p></li>
<li><p><a class="reference external" href="http://mlcourse.ai">mlcourse.ai</a> lectures on gradient boosting: <a class="reference external" href="https://youtu.be/g0ZOtzZqdqk">theory</a> and <a class="reference external" href="https://youtu.be/V5158Oug4W8">practice</a></p></li>
<li><p><a class="reference external" href="https://statweb.stanford.edu/~jhf/ftp/trebst.pdf">Original article</a> about GBM from Jerome Friedman</p></li>
<li><p>“Gradient boosting machines, a tutorial”, <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3885826/">paper</a> by Alexey Natekin, and Alois Knoll</p></li>
<li><p><a class="reference external" href="http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf">Chapter in Elements of Statistical Learning</a> from Hastie, Tibshirani, Friedman (page 337)</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Gradient_boosting">Wiki</a> article about Gradient Boosting</p></li>
<li><p><a class="reference external" href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">Introduction to boosted trees (Xgboost docs)</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=wPqtzj5VZus">Video-lecture by Hastie</a> about GBM at <a class="reference external" href="http://h2o.ai">h2o.ai</a> conference</p></li>
<li><p><a class="reference external" href="https://towardsdatascience.com/catboost-vs-light-gbm-vs-xgboost-5f93620723db">CatBoost vs. Light GBM vs. XGBoost</a> on “Towards Data Science”</p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/1809.04559">Benchmarking and Optimization of
Gradient Boosting Decision Tree Algorithms</a>, <a class="reference external" href="https://arxiv.org/abs/1806.11248">XGBoost: Scalable GPU Accelerated Learning</a> - benchmarking CatBoost, Light GBM, and XGBoost (no 100% winner)</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./book/topic10"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="topic10_intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Topic 10. Gradient Boosting</p>
      </div>
    </a>
    <a class="right-next"
       href="videolecture10.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Videolecture 10. Gradient boosting</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#article-outline">Article outline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction-and-history-of-boosting">1.  Introduction and history of boosting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#history-of-gbm">History of GBM</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#gbm-algorithm">2. GBM algorithm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ml-problem-statement">ML problem statement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#functional-gradient-descent">Functional gradient descent</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#friedman-s-classic-gbm-algorithm">Friedman’s classic GBM algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-by-step-example-how-gbm-works">Step-By-Step example: How GBM Works</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#loss-functions">3. Loss functions</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#regression-loss-functions">Regression loss functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classification-loss-functions">Classification loss functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weights">Weights</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion">4. Conclusion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#useful-resources">5. Useful resources</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Yury Kashnitsky (yorko)
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>